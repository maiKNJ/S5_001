//
// Compute shader to convert RGB data to standard YCbCr 
// formats. This is a more compact format for streaming
// see: https://www.fourcc.org/pixel-format/yuv-uyvy/

uint width;
uint height;
Texture2D<float4> RGBData;
RWStructuredBuffer<uint> YCbCrData;

// ========== BT.601 RGB->YCbCr conversion ==========
// https://www.itu.int/rec/R-REC-BT.601

static const float3x3 BT601Constants =
{
	// [  0.2990,  0.5870,  0.1140 ]   [219]
	// [ -0.1687, -0.3313,  0.5000 ] x [224]
	// [  0.5000, -0.4187, -0.0813 ]   [224] 

	{   65.4810,  128.5530,   24.9660 },
	{  -38.7888,  -74.2112,  112.0000 },
	{  112.0000,  -93.7888,  -18.2112 }
};
uint3 RGBtoYCbCr_BT601(in float3 rgb)
{
	float3 ycbcr = rgb;
	ycbcr = mul(BT601Constants, ycbcr);
	ycbcr += float3(16.0, 128.0, 128.0);
	ycbcr = clamp(ycbcr, float3(16.0, 16.0, 16.0), float3(235.0, 240.0, 240.0));

	return (uint3)ycbcr;
}

// ==================================================


// ========== BT.709 RGB->YCbCr conversion ==========
// https://www.itu.int/rec/R-REC-BT.709

static const float3x3 BT709Constants =
{
	//	[  0.2126,  0.7152,  0.0722 ]   [219]
	//	[ -0.1146, -0.3854,  0.5000 ] x [224]
	//	[  0.5000, -0.4542, -0.0458 ]   [224]

	{  46.5594, 156.6288,  15.8118 },
	{ -25.0974, -84.4026, 109.5000 },
	{ 109.5000, -99.4698, -10.0302 }
};
uint3 RGBtoYCbCr_BT709(in float3 rgb)
{
	float3 ycbcr = rgb;
	ycbcr = mul(BT709Constants, ycbcr);
	ycbcr += float3(16.0, 128.0, 128.0);
	ycbcr = clamp(ycbcr, float3(16.0, 16.0, 16.0), float3(235.0, 240.0, 240.0));

	return (uint3)ycbcr;
}

// ==================================================


// ========== BT.2020 RGB->YCbCr conversion =========
// https://www.itu.int/rec/R-REC-BT.2020

static const float3x3 BT2020Constants =
{
	// [  0.2627,  0.6780,  0.0593 ]   [219]
	// [ -0.1396, -0.3604,  0.5000 ] x [224]
	// [  0.5000, -0.4602, -0.0402 ]   [224]

	{  57.5313,  148.4820,  12.9867 },
	{ -31.2704,  -80.7296, 112.0000 },
	{ 112.0000, -103.0848,  -9.0048 }
};
uint3 RGBtoYCbCr_BT2020(in float3 rgb)
{
	float3 ycbcr = rgb;
	ycbcr = mul(BT2020Constants, ycbcr);
	ycbcr += float3(16.0, 128.0, 128.0);
	ycbcr = clamp(ycbcr, float3(16.0, 16.0, 16.0), float3(235.0, 240.0, 240.0));

	return (uint3)ycbcr;
}

// ==================================================

               
// =========== linear to sRGB conversion ============

float3 linearTosRGB(in float3 rgbLinear)
{
	// http://chilliant.blogspot.com/2012/08/srgb-approximations-for-hlsl.html
	return max(1.055 * pow(abs(rgbLinear), 0.416666667) - 0.055, 0);
}

// ==================================================


#define DEFINE_CONVERSION(format) \
	[numthreads(32,32,1)] \
	void Convert_##format(uint3 DTid : SV_DispatchThreadID) \
	{														\
		/* get index of the source texels */				\
		int3 i0 = int3(DTid.x * 2, height - DTid.y, 0);		\
		int3 i1 = i0 + int3(1, 0, 0);						\
															\
		/* get RGB data from source texture */				\
		float3 rgb0 = RGBData.Load(i0).rgb;					\
		float3 rgb1 = RGBData.Load(i1).rgb;					\
															\
		/* convert RGB to YCbCr */							\
		uint3 v0 = RGBtoYCbCr_##format(rgb0);				\
		uint3 v1 = RGBtoYCbCr_##format(rgb1);				\
															\
		/* combine YCbCr data into output value	*/			\
		/* [ Cb ] [ Y0 ] [ Cr ] [ Y1 ] */					\
		uint output = 0;									\
		output |= (((v0.y + v1.y) >> 1) & 0xFF);			\
		output |= ((v0.x & 0xFF) << 8);						\
		output |= ((((v0.z + v1.z) >> 1) & 0xFF) << 16);	\
		output |= ((v1.x & 0xFF) << 24);					\
															\
		/* write YCbCr data into output buffer */			\
		uint destIndex = (DTid.y * width) + DTid.x;			\
		YCbCrData[destIndex] = output;						\
	}

#define DEFINE_CONVERSION_LINEAR(format) \
	[numthreads(32,32,1)] \
	void Convert_##format##_linear(uint3 DTid : SV_DispatchThreadID) \
	{														\
		/* get index of the source texels */				\
		int3 i0 = int3(DTid.x * 2, height - DTid.y, 0);		\
		int3 i1 = i0 + int3(1, 0, 0);						\
															\
		/* get RGB data from source texture */				\
		float3 rgb0 = RGBData.Load(i0).rgb;					\
		float3 rgb1 = RGBData.Load(i1).rgb;					\
															\
		/* convert from linear to gamma colorspace */		\
		rgb0 = linearTosRGB(rgb0);							\
		rgb1 = linearTosRGB(rgb1);							\
															\
		/* convert RGB to YCbCr */							\
		uint3 v0 = RGBtoYCbCr_##format(rgb0);				\
		uint3 v1 = RGBtoYCbCr_##format(rgb1);				\
															\
		/* combine YCbCr data into output value	*/			\
		/* [ Cb ] [ Y0 ] [ Cr ] [ Y1 ] */					\
		uint output = 0;									\
		output |= (((v0.y + v1.y) >> 1) & 0xFF);			\
		output |= ((v0.x & 0xFF) << 8);						\
		output |= ((((v0.z + v1.z) >> 1) & 0xFF) << 16);	\
		output |= ((v1.x & 0xFF) << 24);					\
															\
		/* write YCbCr data into output buffer */			\
		uint destIndex = (DTid.y * width) + DTid.x;			\
		YCbCrData[destIndex] = output;						\
	}

DEFINE_CONVERSION(BT601)
DEFINE_CONVERSION(BT709)
DEFINE_CONVERSION(BT2020)
DEFINE_CONVERSION_LINEAR(BT601)
DEFINE_CONVERSION_LINEAR(BT709)
DEFINE_CONVERSION_LINEAR(BT2020)

#pragma kernel Convert_BT601
#pragma kernel Convert_BT709
#pragma kernel Convert_BT2020
#pragma kernel Convert_BT601_linear
#pragma kernel Convert_BT709_linear
#pragma kernel Convert_BT2020_linear
